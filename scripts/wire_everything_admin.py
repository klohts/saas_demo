#!/usr/bin/env python3
"""
one-click wire script
Place at: saas_demo/scripts/wire_everything_admin.py
Run: python saas_demo/scripts/wire_everything_admin.py
What it does:
 - Builds frontend (npm --prefix frontend run build)
 - Patches main_admin_intel.py with admin API endpoints and frontend serving
 - Backs up modified files before changing
 - Updates frontend/src/App.jsx (backing up original)
 - Restarts uvicorn
"""
import os, sys, shutil, subprocess, re, time

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
MAIN_PY = os.path.join(ROOT, "main_admin_intel.py")
FRONTEND_DIR = os.path.join(ROOT, "frontend")
FRONTEND_BUILD_DIR = os.path.join(FRONTEND_DIR, "dist")
APP_JSX = os.path.join(FRONTEND_DIR, "src", "App.jsx")
ADMIN_COMPONENT_PATH = os.path.join(FRONTEND_DIR, "src", "components", "AdminDashboard.jsx")
SCRIPT_MARKER = "### ADMIN DASHBOARD INJECTED ###"

def abort(msg):
    print("‚ùå", msg)
    sys.exit(1)

def run(cmd, cwd=None, check=True):
    print("üîÅ Running:", cmd)
    res = subprocess.run(cmd, shell=True, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    print(res.stdout, end="")
    if res.stderr:
        print(res.stderr, end="")
    if check and res.returncode != 0:
        abort(f"Command failed: {cmd}")
    return res

# 0. Basic checks
if not os.path.exists(MAIN_PY):
    abort(f"{MAIN_PY} not found. Run this from the project root.")

if not os.path.exists(FRONTEND_DIR):
    abort(f"{FRONTEND_DIR} not found. Create the frontend (vite) app first.")

print(f"Working in project root: {ROOT}")

# 1. Build frontend
print("\n=== 1) Building frontend (production) ===")
run("npm --version", check=False)
# prefer npm run build in frontend
run("npm --prefix frontend run build", cwd=ROOT, check=True)

if not os.path.exists(FRONTEND_BUILD_DIR):
    abort("Frontend build failed: dist directory not created.")

print("‚úÖ Frontend build found at:", FRONTEND_BUILD_DIR)

# 2. Backup main_admin_intel.py
bak_path = MAIN_PY + ".bak"
if not os.path.exists(bak_path):
    shutil.copy2(MAIN_PY, bak_path)
    print("Backup created:", bak_path)
else:
    print("Backup already exists:", bak_path)

# 3. Read main_admin_intel.py and patch if needed
with open(MAIN_PY, "r", encoding="utf-8") as f:
    main_src = f.read()

if SCRIPT_MARKER in main_src:
    print("‚ö†Ô∏è main_admin_intel.py already patched. Skipping code injection.")
else:
    print("\n=== 2) Patching main_admin_intel.py with admin endpoints & frontend serving ===")
    injected = """

# {SCRIPT_MARKER}
# DO NOT EDIT THIS BLOCK MANUALLY ‚Äî generated by scripts/wire_everything_admin.py
import sqlite3
import asyncio
from fastapi import HTTPException

# Determine DB_PATH used by the app (fallback to admin_intel.db)
try:
    DB_PATH  # if defined earlier in file
except NameError:
    DB_PATH = os.path.join(os.path.dirname(__file__), "admin_intel.db")

# Ensure tables for email logs / queue
def init_email_tables():
    with sqlite3.connect(DB_PATH) as db:
        db.execute(\"\"\"CREATE TABLE IF NOT EXISTS email_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_id INTEGER,
            to_email TEXT,
            subject TEXT,
            status TEXT,
            error TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )\"\"\")
        db.execute(\"\"\"CREATE TABLE IF NOT EXISTS email_queue (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_id INTEGER,
            subject TEXT,
            body TEXT,
            to_email TEXT,
            attempts INTEGER DEFAULT 0,
            next_retry_at REAL DEFAULT 0,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )\"\"\")
        db.commit()

def log_email_delivery(event_id, to_email, subject, status, error=None):
    try:
        with sqlite3.connect(DB_PATH) as db:
            db.execute(
                "INSERT INTO email_logs(event_id, to_email, subject, status, error) VALUES (?,?,?,?,?)",
                (event_id, to_email, subject, status, error)
            )
            db.commit()
    except Exception as e:
        logger.exception("Failed to log email delivery: %s", e)

def enqueue_email(event_id, subject, body, to_email):
    try:
        with sqlite3.connect(DB_PATH) as db:
            db.execute(
                "INSERT INTO email_queue(event_id, subject, body, to_email, next_retry_at) VALUES (?,?,?,?,?)",
                (event_id, subject, body, to_email, 0)
            )
            db.commit()
    except Exception as e:
        logger.exception("Failed to enqueue email: %s", e)

# Simple queue processor (async background task)
async def process_email_queue_worker():
    print("Email queue worker started")
    while True:
        try:
            now = time.time()
            with sqlite3.connect(DB_PATH) as db:
                rows = db.execute(
                    "SELECT id,event_id,subject,body,to_email,attempts FROM email_queue WHERE next_retry_at <= ? ORDER BY id ASC LIMIT 10",
                    (now,)
                ).fetchall()

            for row in rows:
                qid = row[0]
                event_id = row[1]
                subject = row[2]
                body = row[3]
                to_email = row[4]
                attempts = row[5] or 0

                ok = False
                try:
                    ok = send_email_sync(subject, body, to_email)
                except Exception as e:
                    logger.exception("send_email_sync raised: %s", e)

                with sqlite3.connect(DB_PATH) as db:
                    if ok:
                        db.execute("DELETE FROM email_queue WHERE id=?", (qid,))
                        log_email_delivery(event_id, to_email, subject, "sent", None)
                    else:
                        attempts += 1
                        backoff = (2 ** attempts) + 1
                        db.execute("UPDATE email_queue SET attempts=?, next_retry_at=? WHERE id=?", (attempts, time.time() + backoff, qid))
                        log_email_delivery(event_id, to_email, subject, "failed", "queued for retry")
                    db.commit()
        except Exception as e:
            logger.exception("Email queue worker error: %s", e)
        await asyncio.sleep(5)

# Socket stats collector
SOCKET_STATS = {"connected_clients": 0, "last_message_ts": None, "total_sent": 0}

# Expose endpoints the AdminDashboard expects
@app.get("/admin/api/socket_stats")
def api_socket_stats():
    return SOCKET_STATS

@app.get("/admin/api/email_queue")
def api_email_queue():
    with sqlite3.connect(DB_PATH) as db:
        db.row_factory = sqlite3.Row
        rows = db.execute("SELECT * FROM email_queue ORDER BY id DESC").fetchall()
        return [dict(r) for r in rows]

@app.post("/admin/api/email_queue/{qid}/retry")
def api_email_retry(qid: int):
    with sqlite3.connect(DB_PATH) as db:
        row = db.execute("SELECT id,event_id,subject,body,to_email FROM email_queue WHERE id=?", (qid,)).fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not found")
        # simply set next_retry_at to now to retry immediately
        db.execute("UPDATE email_queue SET next_retry_at=?, attempts=0 WHERE id=?", (0, qid))
        db.commit()
        return {"status":"requeued"}

@app.delete("/admin/api/email_queue/{qid}")
def api_email_delete(qid: int):
    with sqlite3.connect(DB_PATH) as db:
        db.execute("DELETE FROM email_queue WHERE id=?", (qid,))
        db.commit()
    return {"status":"deleted"}

@app.get("/admin/api/email_logs")
def api_email_logs(limit: int = 200):
    with sqlite3.connect(DB_PATH) as db:
        db.row_factory = sqlite3.Row
        rows = db.execute("SELECT * FROM email_logs ORDER BY id DESC LIMIT ?", (limit,)).fetchall()
        return [dict(r) for r in rows]

# Serve the built frontend (production) at /admin
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse

FRONTEND_DIST = os.path.join(os.path.dirname(__file__), "frontend", "dist")

try:
    # Mount static files folder for assets
    if not any(m.name == "frontend_dist" for m in app.router.routes if hasattr(m, "name")):
        app.mount("/admin/static", StaticFiles(directory=os.path.join(FRONTEND_DIST, "assets")), name="frontend_dist")
except Exception:
    # ignore mount errors if already mounted
    pass

@app.get("/admin")
@app.get("/admin/{catchall:path}")
def serve_admin(catchall: str = ""):
    index_path = os.path.join(FRONTEND_DIST, "index.html")
    if os.path.exists(index_path):
        return FileResponse(index_path)
    return {"error": "Frontend not built. Run `npm run build` in /frontend first."}

# Ensure initialization at startup
@app.on_event("startup")
async def _admin_dashboard_startup():
    try:
        init_email_tables()
    except Exception as e:
        logger.exception("init_email_tables failed: %s", e)
    # start background queue worker only once
    try:
        asyncio.create_task(process_email_queue_worker())
    except Exception as e:
        logger.exception("Failed to start email queue worker: %s", e)

# end injected block
"""

    # Append injection at end of file
    with open(MAIN_PY, "a", encoding="utf-8") as f:
        f.write(injected)
    print("Patched main_admin_intel.py with admin endpoints and frontend serving.")

# 4. Update frontend/src/App.jsx to route /admin -> AdminDashboard (backup original)
if os.path.exists(APP_JSX):
    bak_app = APP_JSX + ".bak"
    if not os.path.exists(bak_app):
        shutil.copy2(APP_JSX, bak_app)
        print("Backed up App.jsx to", bak_app)
    else:
        print("App.jsx backup already exists:", bak_app)
else:
    # if not present, ensure directory exists and create file
    os.makedirs(os.path.dirname(APP_JSX), exist_ok=True)

app_jsx_content = """import { BrowserRouter, Routes, Route } from "react-router-dom";
import AdminDashboard from "./components/AdminDashboard";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/admin/*" element={<AdminDashboard />} />
        <Route path="*" element={<AdminDashboard />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
"""

with open(APP_JSX, "w", encoding="utf-8") as f:
    f.write(app_jsx_content)
print("Updated frontend/src/App.jsx to mount AdminDashboard at /admin")

# 5. Ensure AdminDashboard.jsx exists
if not os.path.exists(ADMIN_COMPONENT_PATH):
    print("‚ö†Ô∏è AdminDashboard.jsx not found at expected path:", ADMIN_COMPONENT_PATH)
    print("Please ensure AdminDashboard.jsx is placed at frontend/src/components/AdminDashboard.jsx")
else:
    print("Found AdminDashboard.jsx at", ADMIN_COMPONENT_PATH)

# 6. Run migrations / ensure DB tables
print("\n=== 3) Ensuring DB tables exist ===")
# Attempt to run a small Python snippet to call init_email_tables via importing main_admin_intel module
try:
    # load module in subprocess to avoid re-import conflicts
    run(f"{sys.executable} -c \"import importlib, sys; sys.path.insert(0, '{ROOT}'); m=importlib.import_module('main_admin_intel'); print('imported main_admin_intel')\"", cwd=ROOT, check=False)
    # we won't try to invoke the startup event here; main app will initialize on uvicorn start
except Exception as e:
    print("Warning: Could not reliably import main_admin_intel now. It will be initialized when uvicorn starts.", e)

# 7. Restart uvicorn
print("\n=== 4) Restarting Uvicorn ===")
# kill existing uvicorn processes (best-effort)
run("pkill -f uvicorn", check=False)
time.sleep(1)
# start uvicorn in background
# use nohup so it doesn't die when script exits
cmd = "set -a && . /home/hp/AIAutomationProjects/saas_demo/.env && set +a && nohup uvicorn main_admin_intel:app --reload > server_uvicorn.log 2>&1 &"
run(cmd, cwd=ROOT, check=False)

print("\n‚úÖ DONE ‚Äî Wiring complete.")
print("Open the Admin dashboard (production build) at: http://127.0.0.1:8000/admin")
print("Dev frontend (vite) remains available at http://localhost:5173/ (if running).")
