#!/usr/bin/env python3
"""
main.py — THE13TH Admin + Session + 2FA upgrade (v1.0.0)

Features:
- Admin login with hashed password (env ADMIN_PASSWORD_HASH)
- 2FA via email (6-digit code) — uses SMTP settings in env
- Session stored in SQLite sessions.db with expiry and role
- Auto-logout after SESSION_TIMEOUT seconds (default 3600 = 1 hour)
- Admin audit logs written to logs/admin_audit.log and SQLite audit DB (data/admin_audit.db)
- Role support: 'admin' or 'superadmin'
- Cookie security via COOKIE_SECURE env var (0/1)
- One-file drop-in; creates DBs & directories as needed
"""

from fastapi import FastAPI, Request, Header, HTTPException, Form, Depends, Response
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from pathlib import Path
from datetime import datetime, timedelta
import sqlite3, os, json, secrets, hashlib, smtplib, logging, string, random

from dotenv import load_dotenv
load_dotenv()

# -----------------------
# Configuration (env)
# -----------------------
APP_ROOT = Path(__file__).resolve().parent
DATA_DIR = APP_ROOT / "data"
LOG_DIR = APP_ROOT / "logs"
TEMPLATES_DIR = APP_ROOT / "templates"
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(TEMPLATES_DIR, exist_ok=True)

# env vars
ADMIN_EMAIL = os.getenv("ADMIN_EMAIL", "admin@the13th.com")
ADMIN_PASSWORD_HASH = os.getenv("ADMIN_PASSWORD_HASH")  # required for production
ADMIN_PASSWORD_DEV = os.getenv("ADMIN_PASSWORD", "th13_superpass")  # fallback for local dev only
COOKIE_SECURE = bool(int(os.getenv("COOKIE_SECURE", "0")))
SESSION_TIMEOUT = int(os.getenv("SESSION_TIMEOUT", str(3600)))  # seconds — default 1 hour
SMTP_HOST = os.getenv("SMTP_HOST", "")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USER = os.getenv("SMTP_USER", "")
SMTP_PASS = os.getenv("SMTP_PASS", "")
SMTP_FROM = os.getenv("SMTP_FROM", SMTP_USER or f"no-reply@{os.getenv('HOSTNAME','the13th.ai')}")

# DB paths
SESSIONS_DB = DATA_DIR / "sessions.db"
AUDIT_DB = DATA_DIR / "admin_audit.db"
# log files
AUDIT_LOG_FILE = LOG_DIR / "admin_audit.log"

# App init
app = FastAPI(title="THE13TH — Admin (Upgraded)")
app.mount("/static", StaticFiles(directory=APP_ROOT / "static"), name="static")
templates = Jinja2Templates(directory=str(TEMPLATES_DIR))

# Basic logger (to file)
log_path = LOG_DIR / f"app_{datetime.utcnow().date()}.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
    handlers=[logging.FileHandler(log_path), logging.StreamHandler()],
)

# -----------------------
# DB init
# -----------------------
def init_sessions_db():
    conn = sqlite3.connect(SESSIONS_DB)
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS sessions (
        token TEXT PRIMARY KEY,
        email TEXT,
        role TEXT,
        created_at TEXT,
        expires_at REAL,
        twofa_code TEXT,
        twofa_expires REAL
    )""")
    conn.commit()
    conn.close()

def init_audit_db():
    conn = sqlite3.connect(AUDIT_DB)
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS admin_audit (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ts TEXT,
        actor TEXT,
        action TEXT,
        meta TEXT
    )""")
    conn.commit()
    conn.close()

init_sessions_db()
init_audit_db()

# Ensure audit log file exists
AUDIT_LOG_FILE.touch(exist_ok=True)

# -----------------------
# Utility functions
# -----------------------
def hash_password(password: str) -> str:
    return hashlib.sha256(password.encode()).hexdigest()

def verify_password(password: str) -> bool:
    # prefer ADMIN_PASSWORD_HASH if present (production)
    if ADMIN_PASSWORD_HASH:
        return hash_password(password) == ADMIN_PASSWORD_HASH
    # fallback to dev plain password (only if ADMIN_PASSWORD_HASH is missing)
    return password == ADMIN_PASSWORD_DEV

def create_session(email: str, role: str="admin", lifetime_seconds: int = SESSION_TIMEOUT):
    token = secrets.token_urlsafe(32)
    now = datetime.utcnow()
    expiry = now + timedelta(seconds=lifetime_seconds)
    conn = sqlite3.connect(SESSIONS_DB)
    c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO sessions (token,email,role,created_at,expires_at) VALUES (?,?,?,?,?)",
              (token, email, role, now.isoformat(), expiry.timestamp()))
    conn.commit(); conn.close()
    return token, expiry

def get_session(token: str):
    conn = sqlite3.connect(SESSIONS_DB)
    c = conn.cursor()
    row = c.execute("SELECT token,email,role,created_at,expires_at,twofa_code,twofa_expires FROM sessions WHERE token=?", (token,)).fetchone()
    conn.close()
    if not row:
        return None
    tkn, email, role, created, exp_ts, twofa_code, twofa_expires = row
    return {
        "token": tkn,
        "email": email,
        "role": role,
        "created_at": created,
        "expires_at": float(exp_ts) if exp_ts else None,
        "twofa_code": twofa_code,
        "twofa_expires": float(twofa_expires) if twofa_expires else None
    }

def extend_session(token: str, extra_seconds: int = SESSION_TIMEOUT):
    now = datetime.utcnow()
    new_exp = (now + timedelta(seconds=extra_seconds)).timestamp()
    conn = sqlite3.connect(SESSIONS_DB)
    c = conn.cursor()
    c.execute("UPDATE sessions SET expires_at=? WHERE token=?", (new_exp, token))
    conn.commit(); conn.close()

def clear_session(token: str):
    conn = sqlite3.connect(SESSIONS_DB)
    c = conn.cursor()
    c.execute("DELETE FROM sessions WHERE token=?", (token,))
    conn.commit(); conn.close()

def record_audit(actor: str, action: str, meta: dict = None):
    ts = datetime.utcnow().isoformat()
    meta_json = json.dumps(meta or {})
    # file log
    with open(AUDIT_LOG_FILE, "a") as f:
        f.write(f"[{ts}] {actor} | {action} | {meta_json}\n")
    # sqlite
    conn = sqlite3.connect(AUDIT_DB)
    c = conn.cursor()
    c.execute("INSERT INTO admin_audit (ts,actor,action,meta) VALUES (?,?,?,?)", (ts, actor, action, meta_json))
    conn.commit(); conn.close()

# 2FA helper — send code via SMTP
def send_2fa_email(to_address: str, code: str):
    if not SMTP_HOST or not SMTP_USER or not SMTP_PASS:
        logging.warning("SMTP not configured — cannot send 2FA email (check SMTP_HOST, SMTP_USER, SMTP_PASS)")
        return False
    subject = "Your THE13TH Admin 2FA Code"
    body = f"Hello — your THE13TH admin login code is: {code}\nThis code is valid for 10 minutes.\n"
    message = f"From: {SMTP_FROM}\r\nTo: {to_address}\r\nSubject: {subject}\r\n\r\n{body}"
    try:
        s = smtplib.SMTP(SMTP_HOST, SMTP_PORT, timeout=10)
        s.starttls()
        s.login(SMTP_USER, SMTP_PASS)
        s.sendmail(SMTP_FROM, [to_address], message.encode("utf-8"))
        s.quit()
        logging.info(f"Sent 2FA email to {to_address}")
        return True
    except Exception as e:
        logging.exception(f"Failed to send 2FA email: {e}")
        return False

def generate_6digit():
    return f"{secrets.randbelow(10**6):06d}"

# -----------------------
# Admin auth dependency
# -----------------------
from fastapi import Cookie

async def auth_admin(request: Request, session_token: str = Cookie(None)):
    """Verifies session cookie, expiry, and role. Extends session on activity."""
    if not session_token:
        raise HTTPException(status_code=401, detail="Not authenticated")
    s = get_session(session_token)
    if not s:
        raise HTTPException(status_code=401, detail="Invalid session")
    # check expiry
    if s["expires_at"] and datetime.utcnow().timestamp() > s["expires_at"]:
        clear_session(session_token)
        raise HTTPException(status_code=401, detail="Session expired")
    # extend session on each protected request
    extend_session(session_token, extra_seconds=SESSION_TIMEOUT)
    request.state.admin = s
    return s

# -----------------------
# Templates: ensure minimal ones exist if missing
# -----------------------
# create a simple admin_login and admin_tools template if absent
def ensure_templates():
    # admin_login.html
    login_t = TEMPLATES_DIR / "admin_login.html"
    if not login_t.exists():
        login_t.write_text("""<!doctype html>
<html><head><title>Admin Login</title></head>
<body>
  <h2>THE13TH Admin Login</h2>
  <form method="post" action="/admin/login">
    <input name="email" placeholder="email" value="{{ email or '' }}" /><br/>
    <input type="password" name="password" placeholder="password" /><br/>
    <button type="submit">Sign in</button>
  </form>
  {% if error %}<p style="color:red">{{ error }}</p>{% endif %}
</body></html>
""")
    # 2fa page
    twofa = TEMPLATES_DIR / "admin_2fa.html"
    if not twofa.exists():
        twofa.write_text("""<!doctype html>
<html><head><title>2FA</title></head>
<body>
  <h3>Enter the 6-digit code sent to your email</h3>
  <form method="post" action="/admin/2fa">
    <input name="token" placeholder="session token" value="{{ token }}" readonly /><br/>
    <input name="code" placeholder="123456" /><br/>
    <button type="submit">Verify</button>
  </form>
  {% if error %}<p style="color:red">{{ error }}</p>{% endif %}
</body></html>
""")
    tools = TEMPLATES_DIR / "admin_tools.html"
    if not tools.exists():
        tools.write_text("""<!doctype html>
<html><head><title>THE13TH Admin</title></head>
<body>
  <h1>THE13TH Admin Panel</h1>
  <p>Welcome, {{ email }}</p>
  <form action="/admin/logout" method="get"><button>Logout</button></form>
  <h3>Actions</h3>
  <form action="/admin/toggle-demo" method="post"><button>Toggle Demo</button></form>
  <a href="/admin/audit-log">View Audit Log</a>
</body></html>
""")
ensure_templates()

# -----------------------
# Admin Routes
# -----------------------
@app.get("/admin/login", response_class=HTMLResponse)
def admin_login_page(request: Request):
    return templates.TemplateResponse("admin_login.html", {"request": request, "email": ADMIN_EMAIL})

@app.post("/admin/login", response_class=HTMLResponse)
def admin_login_submit(request: Request, email: str = Form(...), password: str = Form(...)):
    # --- DEBUG IDENTITY CHECK ---
    import os, hashlib
    env_hash = os.getenv("ADMIN_PASSWORD_HASH")
    submitted_hash = hashlib.sha256(password.encode()).hexdigest() if password else None
    print("\n--- LOGIN DEBUG ---")
    print("ENV HASH:       ", repr(env_hash))
    print("SUBMITTED HASH: ", repr(submitted_hash))
    print("EQUAL?         ", env_hash == submitted_hash)
    print("-------------------\n")
    print("\n--- LOGIN ATTEMPT ---")
    print("Form email:", email)
    print("Form password:", password)
    print("Hash of submitted:", __import__("hashlib").sha256(password.encode()).hexdigest() if password else None)
    # password check
    if email.lower() != ADMIN_EMAIL.lower():
        record_audit(email, "login_failed", {"reason":"unknown_email"})
        return templates.TemplateResponse("admin_login.html", {"request": request, "error": "Invalid credentials"}, status_code=401)
    if not verify_password(password):
        record_audit(email, "login_failed", {"reason":"bad_password"})
        return templates.TemplateResponse("admin_login.html", {"request": request, "error": "Invalid credentials"}, status_code=401)

    # create a temporary session with twofa fields and send email code
    token = secrets.token_urlsafe(24)
    code = generate_6digit()
    now = datetime.utcnow()
    twofa_exp = (now + timedelta(minutes=10)).timestamp()
    conn = sqlite3.connect(SESSIONS_DB)
    c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO sessions (token,email,role,created_at,expires_at,twofa_code,twofa_expires) VALUES (?,?,?,?,?,?,?)",
              (token, email, "pending", now.isoformat(), (now + timedelta(minutes=15)).timestamp(), code, twofa_exp))
    conn.commit(); conn.close()
    # send email
    send_2fa_email(email, code)
    record_audit(email, "2fa_sent", {"token": token})
    # show 2fa page
    return templates.TemplateResponse("admin_2fa.html", {"request": request, "token": token})

@app.post("/admin/2fa")
def admin_2fa_verify(request: Request, token: str = Form(...), code: str = Form(...)):
    # lookup session by token
    s = get_session(token)
    if not s:
        record_audit("unknown", "2fa_fail", {"reason":"no_session", "token": token})
        return templates.TemplateResponse("admin_2fa.html", {"request": request, "error": "Invalid session", "token": token}, status_code=401)
    if s["twofa_expires"] is None or datetime.utcnow().timestamp() > s["twofa_expires"]:
        clear_session(token)
        record_audit(s["email"], "2fa_fail", {"reason":"expired"})
        return templates.TemplateResponse("admin_2fa.html", {"request": request, "error": "Code expired", "token": token}, status_code=401)
    if code != s["twofa_code"]:
        record_audit(s["email"], "2fa_fail", {"reason":"bad_code"})
        return templates.TemplateResponse("admin_2fa.html", {"request": request, "error": "Invalid code", "token": token}, status_code=401)

    # 2FA ok — promote session to admin role and set cookie
    conn = sqlite3.connect(SESSIONS_DB)
    c = conn.cursor()
    new_exp = (datetime.utcnow() + timedelta(seconds=SESSION_TIMEOUT)).timestamp()
    c.execute("UPDATE sessions SET role=?, expires_at=?, twofa_code=NULL, twofa_expires=NULL WHERE token=?", ("admin", new_exp, token))
    conn.commit(); conn.close()
    record_audit(s["email"], "login_success", {"token": token})
    res = RedirectResponse("/admin/tools", status_code=303)
    res.set_cookie("session_token", token, httponly=True, secure=COOKIE_SECURE, samesite="lax", max_age=SESSION_TIMEOUT)
    return res

@app.get("/admin/logout")
def admin_logout(session_token: str = None, response: Response = None):
    # clear cookie and session
    token = None
    # read cookie via Request fallback if needed
    def _get_cookie(req: Request):
        return req.cookies.get("session_token")
    # We can't access Request here reliably, but clearing by cookie is okay in client
    # best effort: instruct user to clear cookie in browser if needed
    return RedirectResponse("/admin/login", status_code=303)

# Protected admin tools
@app.get("/admin/tools", response_class=HTMLResponse)
def admin_tools(request: Request, session = Depends(auth_admin)):
    email = session["email"]
    return templates.TemplateResponse("admin_tools.html", {"request": request, "email": email})

@app.post("/admin/toggle-demo")
def toggle_demo(session = Depends(auth_admin)):
    # minimal toggle action
    # persist to a file flag
    flag_file = DATA_DIR / "demo_mode.flag"
    if flag_file.exists():
        flag_file.unlink()
        status = "deactivated"
    else:
        flag_file.write_text("1")
        status = "activated"
    record_audit(session["email"], "toggle_demo", {"status": status})
    return RedirectResponse("/admin/tools", status_code=303)

# Audit log viewer + export
@app.get("/admin/audit-log", response_class=HTMLResponse)
def view_audit_log(request: Request, export: bool = False, session = Depends(auth_admin)):
    conn = sqlite3.connect(AUDIT_DB)
    c = conn.cursor()
    rows = c.execute("SELECT ts,actor,action,meta FROM admin_audit ORDER BY id DESC LIMIT 500").fetchall()
    conn.close()
    entries = [{"ts": r[0], "actor": r[1], "action": r[2], "meta": json.loads(r[3] or "{}")} for r in rows]
    if export:
        return JSONResponse(entries)
    # plain html render
    html = "<h2>Admin Audit Log</h2><a href='/admin/tools'>Back</a><ul>"
    for e in entries:
        html += f"<li>[{e['ts']}] {e['actor']} - {e['action']} - {e['meta']}</li>"
    html += "</ul>"
    return HTMLResponse(html)

@app.post("/admin/clear-audit")
def clear_audit_logs(session = Depends(auth_admin)):
    open(AUDIT_LOG_FILE, "w").write("")
    conn = sqlite3.connect(AUDIT_DB)
    c = conn.cursor()
    c.execute("DELETE FROM admin_audit")
    conn.commit(); conn.close()
    record_audit("system", "audit_cleared", {})
    return RedirectResponse("/admin/audit-log", status_code=303)

# Health & simple routes
@app.get("/", response_class=HTMLResponse)
def home():
    return HTMLResponse("<h3>THE13TH API — Upgraded Admin</h3><a href='/admin/login'>Admin</a>")

@app.get("/health")
def health():
    return {"status": "ok", "timestamp": datetime.utcnow().isoformat()}

# -----------------------
# Quick notes printed on startup
# -----------------------
@app.on_event("startup")
def startup_event():
    logging.info("THE13TH admin upgrade v1.0.0 starting up")
    logging.info(f"Admin email: {ADMIN_EMAIL}")
    logging.info(f"Cookie secure: {COOKIE_SECURE}")
    logging.info(f"Session timeout (secs): {SESSION_TIMEOUT}")
    if not ADMIN_PASSWORD_HASH:
        logging.warning("ADMIN_PASSWORD_HASH not set — running in DEV fallback mode (insecure). Set ADMIN_PASSWORD_HASH in .env for production.")
    if SMTP_HOST and SMTP_USER and SMTP_PASS:
        logging.info("SMTP configured for 2FA email delivery")
    else:
        logging.warning("SMTP not fully configured — 2FA email will not be sent. Set SMTP_HOST, SMTP_USER, SMTP_PASS, SMTP_PORT.")

# End of file
