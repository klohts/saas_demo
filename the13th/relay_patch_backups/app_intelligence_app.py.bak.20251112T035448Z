from __future__ import annotations
import os
import sys
import logging
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any

from fastapi import FastAPI, HTTPException, Request, Header, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles

from sqlmodel import SQLModel, Field as ORMField, create_engine, Session, select, col

# -------- Config & paths --------
BASE_DIR = Path(__file__).resolve().parent
DATA_DIR = BASE_DIR / "data"
DIST_DIR = BASE_DIR / "dist"
ASSETS_DIR = DIST_DIR / "assets"

DATA_DIR.mkdir(parents=True, exist_ok=True)
DIST_DIR.mkdir(parents=True, exist_ok=True)
ASSETS_DIR.mkdir(parents=True, exist_ok=True)

DATABASE_URL = os.getenv("AI_DATABASE_URL", f"sqlite:///{DATA_DIR / 'events.db'}")
SYS_API_KEY = os.getenv("CC_SYS_API_KEY", "supersecret_sys_key")
PORT = int(os.getenv("AI_PORT", "8011"))
RATE_LIMIT_PER_MIN = int(os.getenv("AI_RATE_LIMIT_PER_MIN", "120"))

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(name)s:%(lineno)d - %(message)s")
logger = logging.getLogger("app_intelligence")

# -------- DB models --------
from sqlalchemy import Column, JSON

class Event(SQLModel, table=True):
    id: Optional[int] = ORMField(default=None, primary_key=True)
    client_id: str = ORMField(index=True)
    action: str
    user: Optional[str] = None
    meta: Optional[Dict[str, Any]] = ORMField(default=None, sa_column=Column("metadata", JSON))
    created_at: datetime = ORMField(default_factory=datetime.utcnow)

# -------- DB utils --------
engine = create_engine(DATABASE_URL, echo=False, connect_args={"check_same_thread": False} if DATABASE_URL.startswith("sqlite") else {})

def init_db() -> None:
    SQLModel.metadata.create_all(engine)
    logger.info("Initialized DB at %s", DATABASE_URL)

def get_session() -> Session:
    return Session(engine)

# -------- App --------
app = FastAPI(title="THE13TH â€” App Intelligence", version="1.0.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("AI_CORS_ORIGINS", "*").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# serve static dashboard build if present
if DIST_DIR.exists():
    try:
        app.mount("/assets", StaticFiles(directory=str(ASSETS_DIR)), name="assets")
        @app.get("/dashboard", response_class=HTMLResponse, include_in_schema=False)
        def dashboard_index():
            index_html = DIST_DIR / "index.html"
            if index_html.exists():
                return FileResponse(index_html)
            return HTMLResponse("<html><body><h3>Dashboard not built</h3></body></html>", status_code=404)
    except Exception:
        logger.exception("Failed to mount static files")

# -------- Error handlers --------
@app.exception_handler(Exception)
def generic_exception_handler(request: Request, exc: Exception):
    logger.exception("Unhandled exception: %s", exc)
    return JSONResponse({"detail": "Internal Server Error"}, status_code=500)

# -------- Startup --------
@app.on_event("startup")
def startup_event():
    init_db()
    logger.info("App Intelligence startup complete")

# -------- Health --------
@app.get("/healthz", tags=["health"])
def healthz():
    return {"status": "ok", "app": "THE13TH App Intelligence"}

# -------- Event ingestion --------
@app.post("/api/events", status_code=201)
def create_event(payload: dict, x_sys_api_key: Optional[str] = Header(None)):
    # Basic sys key check (best-effort; control core handles orchestration)
    if x_sys_api_key is None or x_sys_api_key != SYS_API_KEY:
        logger.warning("Invalid system api key attempt")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid system API Key")
    # validate payload minimally
    client_id = payload.get("client_id")
    action = payload.get("action")
    if not client_id or not action:
        raise HTTPException(status_code=400, detail="client_id and action required")
    metadata = payload.get("metadata") or {}
    user = payload.get("user")
    created_at = payload.get("timestamp")
    if created_at:
        try:
            created_at = datetime.fromisoformat(created_at)
        except Exception:
            created_at = datetime.utcnow()
    else:
        created_at = datetime.utcnow()
    with get_session() as sess:
        row = Event(client_id=client_id, action=action, user=user, metadata=metadata, created_at=created_at)
        sess.add(row)
        sess.commit()
        sess.refresh(row)
        logger.info("Stored event id=%s client=%s action=%s", row.id, row.client_id, row.action)
        return {"id": row.id, "created_at": row.created_at.isoformat()}

# -------- Insights endpoints --------
@app.get("/api/insights/recent")
def insights_recent(limit: int = 50, x_sys_api_key: Optional[str] = Header(None)):
    if x_sys_api_key is None or x_sys_api_key != SYS_API_KEY:
        raise HTTPException(status_code=401, detail="Invalid system API Key")
    with get_session() as sess:
        rows = sess.exec(select(Event).order_by(col(Event.created_at).desc()).limit(limit)).all()
        out = []
        for r in rows:
            out.append({"id": r.id, "client_id": r.client_id, "action": r.action, "user": r.user, "metadata": r.metadata or {}, "created_at": r.created_at.isoformat()})
        return {"events": out}

@app.get("/api/insights/summary")
def insights_summary(days: int = 7, x_sys_api_key: Optional[str] = Header(None)):
    if x_sys_api_key is None or x_sys_api_key != SYS_API_KEY:
        raise HTTPException(status_code=401, detail="Invalid system API Key")
    cutoff = datetime.utcnow() - timedelta(days=days)
    with get_session() as sess:
        total = sess.exec(select(Event).where(Event.created_at >= cutoff)).count()
        unique_clients = len(sess.exec(select(Event.client_id).where(Event.created_at >= cutoff)).all())
        # simple top actions
        rows = sess.exec(select(Event.action).where(Event.created_at >= cutoff)).all()
        counts: Dict[str, int] = {}
        for a in rows:
            counts[a] = counts.get(a, 0) + 1
        top_actions = sorted([{"action": k, "count": v} for k, v in counts.items()], key=lambda x: -x["count"])
        return {"total_events": total, "unique_clients": unique_clients, "top_actions": top_actions}
