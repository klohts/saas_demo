# Auto-generated secure auth helper (created by setup_secure_admin.py)
import os, sqlite3, time, secrets, hashlib, hmac
from datetime import datetime, timedelta
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
DATA_DIR = BASE_DIR / "data"
DATA_DIR.mkdir(parents=True, exist_ok=True)
DB_PATH = str(DATA_DIR / "sessions.db")

# PBKDF2 params
_PBKDF2_ITER = 150000
_SALT = 'the13th-default-salt'.encode("utf-8")

def make_password_hash(password: str) -> str:
    dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), _SALT, _PBKDF2_ITER)
    return dk.hex()

def verify_password(password: str, stored_hash: str) -> bool:
    return hmac.compare_digest(make_password_hash(password), stored_hash)

def get_admin_password_hash() -> str:
    h = os.environ.get("ADMIN_PASSWORD_HASH")
    if h:
        return h
    # fallback: if ADMIN_PASSWORD set (dev), hash that
    p = os.environ.get("ADMIN_PASSWORD", "The13th@2025")
    return make_password_hash(p)

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
        token TEXT PRIMARY KEY,
        email TEXT,
        role TEXT DEFAULT 'admin',
        created_at TEXT,
        expires_at TEXT
    )
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS audit_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ts TEXT,
        actor TEXT,
        event TEXT,
        details TEXT
    )
    """)
    conn.commit()
    # safe-alter for older schemas
    existing = [r[1] for r in c.execute("PRAGMA table_info(sessions)").fetchall()]
    if "role" not in existing:
        try: c.execute("ALTER TABLE sessions ADD COLUMN role TEXT DEFAULT 'admin'")
        except: pass
    if "email" not in existing:
        try: c.execute("ALTER TABLE sessions ADD COLUMN email TEXT")
        except: pass
    if "created_at" not in existing:
        try: c.execute("ALTER TABLE sessions ADD COLUMN created_at TEXT")
        except: pass
    if "expires_at" not in existing:
        try: c.execute("ALTER TABLE sessions ADD COLUMN expires_at TEXT")
        except: pass
    conn.commit()
    conn.close()

# initialize eagerly
init_db()

# Magic link + session helpers
def create_magic_link(email: str) -> str:
    token = secrets.token_urlsafe(24)
    expires_at = time.time() + 900
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    now = datetime.utcnow().isoformat()
    c.execute("INSERT INTO sessions (token, email, created_at, expires_at, role) VALUES (?, ?, ?, ?, ?)",
              (token, email, now, str(time.time() + 900), "client"))
    conn.commit(); conn.close()
    return f"https://the13th.onrender.com/client/login?token={token}".replace("{token}", token)

def validate_token(token: str):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT email, expires_at FROM sessions WHERE token=?", (token,))
    row = c.fetchone()
    conn.close()
    if not row: return None
    email, exp = row
    try:
        if float(exp) < time.time(): return None
    except: pass
    return email

# webhook / email log
import requests
def notify_webhook(status: str, recipient: str, message: str = ""):
    url = os.getenv("WEBHOOK_URL")
    if not url: return
    payload = { "content": f"ðŸ“¡ **THE13TH Email {status.upper()}** â†’ {recipient}\n{message}" }
    try:
        requests.post(url, json=payload, timeout=10)
    except Exception as e:
        print(f"âš ï¸ Webhook notification failed: {e}")

def log_email_delivery(recipient: str, status: str, message: str = ""):
    log_dir = Path(__file__).resolve().parent.parent / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    log_path = log_dir / "email_delivery.log"
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{timestamp}] {status.upper()} â€” {recipient} â€” {message}\n"
    with open(log_path, "a") as f:
        f.write(line)
    notify_webhook(status, recipient, message)

# audit helper
def log_audit(actor: str, event: str, details: str = ""):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("INSERT INTO audit_logs (ts, actor, event, details) VALUES (?, ?, ?, ?)",
              (datetime.utcnow().isoformat(), actor, event, details))
    conn.commit(); conn.close()

# admin auth dependency and session helpers
from fastapi import Request, HTTPException

def auth_admin(request: Request):
    session_token = request.cookies.get("session_token")
    if not session_token:
        raise HTTPException(status_code=401, detail="Unauthorized")
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("SELECT role, email, expires_at FROM sessions WHERE token=?", (session_token,))
        row = c.fetchone()
        conn.close()
        if not row:
            raise HTTPException(status_code=401, detail="Unauthorized")
        role, email, exp = row[0], row[1], row[2]
        if role != "admin":
            raise HTTPException(status_code=403, detail="Forbidden")
        try:
            if exp and float(exp) < time.time():
                raise HTTPException(status_code=401, detail="Session expired")
        except Exception:
            pass
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(status_code=401, detail="Unauthorized")
    return session_token

def verify_admin_credentials(email: str, password: str) -> bool:
    stored_hash = get_admin_password_hash()
    admin_email = os.environ.get("ADMIN_EMAIL", "admin@the13th.com").lower()
    return email.lower() == admin_email and verify_password(password, stored_hash)

def create_admin_session():
    token = secrets.token_urlsafe(32)
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS sessions (
            token TEXT PRIMARY KEY,
            email TEXT,
            role TEXT DEFAULT 'admin',
            created_at TEXT,
            expires_at TEXT
        )
    """)
    now = datetime.utcnow()
    expiry = now + timedelta(hours=6)
    admin_email = os.environ.get("ADMIN_EMAIL", "admin@the13th.com")
    c.execute(
        "INSERT OR REPLACE INTO sessions (token, email, role, created_at, expires_at) VALUES (?, ?, ?, ?, ?)",
        (token, admin_email, "admin", now.isoformat(), expiry.timestamp())
    )
    conn.commit(); conn.close()
    log_audit(admin_email, "login", f"created session {token[:8]}...")
    return token

def invalidate_session(token: str):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT email FROM sessions WHERE token=?", (token,))
    row = c.fetchone()
    email = row[0] if row else "unknown"
    c.execute("DELETE FROM sessions WHERE token=?", (token,))
    conn.commit(); conn.close()
    log_audit(email, "logout", f"invalidate {token[:8]}")
    return True
